import { __decorate, __param } from "tslib";
import { Inject, Injectable } from '@angular/core';
import { swalProviderToken } from './di';
var SweetAlert2LoaderService = /** @class */ (function () {
    // Using any because Angular metadata generator does not understand a pure TS type here
    function SweetAlert2LoaderService(swalProvider) {
        this.swalProvider = swalProvider;
    }
    Object.defineProperty(SweetAlert2LoaderService.prototype, "swal", {
        get: function () {
            if (!this.swalPromiseCache) {
                this.preloadSweetAlertLibrary();
            }
            return this.swalPromiseCache;
        },
        enumerable: true,
        configurable: true
    });
    SweetAlert2LoaderService.prototype.preloadSweetAlertLibrary = function () {
        if (this.swalPromiseCache)
            return;
        var libPromise = isLoader(this.swalProvider)
            ? this.swalProvider()
            : Promise.resolve(this.swalProvider);
        this.swalPromiseCache = libPromise.then(function (value) { return isDefaultExport(value) ? value : value.default; });
        function isLoader(value) {
            return typeof value === 'function' && value.version === undefined;
        }
        function isDefaultExport(value) {
            return typeof value === 'function';
        }
    };
    SweetAlert2LoaderService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [swalProviderToken,] }] }
    ]; };
    SweetAlert2LoaderService = __decorate([
        Injectable(),
        __param(0, Inject(swalProviderToken))
    ], SweetAlert2LoaderService);
    return SweetAlert2LoaderService;
}());
export { SweetAlert2LoaderService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3dlZXRhbGVydDItbG9hZGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Ac3dlZXRhbGVydDIvbmd4LXN3ZWV0YWxlcnQyLyIsInNvdXJjZXMiOlsibGliL3N3ZWV0YWxlcnQyLWxvYWRlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUVuRCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFTekM7SUFLSSx1RkFBdUY7SUFDdkYsa0NBQThDLFlBQWlCO1FBQzNELElBQUksQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDO0lBQ3JDLENBQUM7SUFFRCxzQkFBVywwQ0FBSTthQUFmO1lBQ0ksSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtnQkFDeEIsSUFBSSxDQUFDLHdCQUF3QixFQUFFLENBQUM7YUFDbkM7WUFFRCxPQUFPLElBQUksQ0FBQyxnQkFBaUIsQ0FBQztRQUNsQyxDQUFDOzs7T0FBQTtJQUVNLDJEQUF3QixHQUEvQjtRQUNJLElBQUksSUFBSSxDQUFDLGdCQUFnQjtZQUFFLE9BQU87UUFFbEMsSUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUM7WUFDMUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDckIsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBRXpDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQUEsS0FBSyxJQUFJLE9BQUEsZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQTlDLENBQThDLENBQUMsQ0FBQztRQUVqRyxTQUFTLFFBQVEsQ0FBQyxLQUFtQjtZQUNqQyxPQUFPLE9BQU8sS0FBSyxLQUFLLFVBQVUsSUFBSyxLQUFhLENBQUMsT0FBTyxLQUFLLFNBQVMsQ0FBQztRQUMvRSxDQUFDO1FBRUQsU0FBUyxlQUFlLENBQUMsS0FBaUI7WUFDdEMsT0FBTyxPQUFPLEtBQUssS0FBSyxVQUFVLENBQUM7UUFDdkMsQ0FBQztJQUNMLENBQUM7O2dEQTVCbUIsTUFBTSxTQUFDLGlCQUFpQjs7SUFObkMsd0JBQXdCO1FBRHBDLFVBQVUsRUFBRTtRQU9XLFdBQUEsTUFBTSxDQUFDLGlCQUFpQixDQUFDLENBQUE7T0FOcEMsd0JBQXdCLENBbUNwQztJQUFELCtCQUFDO0NBQUEsQUFuQ0QsSUFtQ0M7U0FuQ1ksd0JBQXdCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgU3dhbERlZmF1bHQsICogYXMgU3dhbCBmcm9tICdzd2VldGFsZXJ0Mic7XG5pbXBvcnQgeyBzd2FsUHJvdmlkZXJUb2tlbiB9IGZyb20gJy4vZGknO1xuXG5leHBvcnQgdHlwZSBTd2FsTW9kdWxlID0gdHlwZW9mIFN3YWxEZWZhdWx0IHwgdHlwZW9mIFN3YWw7XG5cbmV4cG9ydCB0eXBlIFN3YWxQcm92aWRlciA9IFN3YWxNb2R1bGVMb2FkZXIgfCBTd2FsTW9kdWxlO1xuXG5leHBvcnQgdHlwZSBTd2FsTW9kdWxlTG9hZGVyID0gKCkgPT4gUHJvbWlzZTxTd2FsTW9kdWxlPjtcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFN3ZWV0QWxlcnQyTG9hZGVyU2VydmljZSB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBzd2FsUHJvdmlkZXI6IFN3YWxQcm92aWRlcjtcblxuICAgIHByaXZhdGUgc3dhbFByb21pc2VDYWNoZT86IFByb21pc2U8dHlwZW9mIFN3YWxEZWZhdWx0PjtcblxuICAgIC8vIFVzaW5nIGFueSBiZWNhdXNlIEFuZ3VsYXIgbWV0YWRhdGEgZ2VuZXJhdG9yIGRvZXMgbm90IHVuZGVyc3RhbmQgYSBwdXJlIFRTIHR5cGUgaGVyZVxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihASW5qZWN0KHN3YWxQcm92aWRlclRva2VuKSBzd2FsUHJvdmlkZXI6IGFueSkge1xuICAgICAgICB0aGlzLnN3YWxQcm92aWRlciA9IHN3YWxQcm92aWRlcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHN3YWwoKTogUHJvbWlzZTx0eXBlb2YgU3dhbERlZmF1bHQ+IHtcbiAgICAgICAgaWYgKCF0aGlzLnN3YWxQcm9taXNlQ2FjaGUpIHtcbiAgICAgICAgICAgIHRoaXMucHJlbG9hZFN3ZWV0QWxlcnRMaWJyYXJ5KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5zd2FsUHJvbWlzZUNhY2hlITtcbiAgICB9XG5cbiAgICBwdWJsaWMgcHJlbG9hZFN3ZWV0QWxlcnRMaWJyYXJ5KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5zd2FsUHJvbWlzZUNhY2hlKSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgbGliUHJvbWlzZSA9IGlzTG9hZGVyKHRoaXMuc3dhbFByb3ZpZGVyKVxuICAgICAgICAgICAgPyB0aGlzLnN3YWxQcm92aWRlcigpXG4gICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZSh0aGlzLnN3YWxQcm92aWRlcik7XG5cbiAgICAgICAgdGhpcy5zd2FsUHJvbWlzZUNhY2hlID0gbGliUHJvbWlzZS50aGVuKHZhbHVlID0+IGlzRGVmYXVsdEV4cG9ydCh2YWx1ZSkgPyB2YWx1ZSA6IHZhbHVlLmRlZmF1bHQpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGlzTG9hZGVyKHZhbHVlOiBTd2FsUHJvdmlkZXIpOiB2YWx1ZSBpcyBTd2FsTW9kdWxlTG9hZGVyIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgKHZhbHVlIGFzIGFueSkudmVyc2lvbiA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNEZWZhdWx0RXhwb3J0KHZhbHVlOiBTd2FsTW9kdWxlKTogdmFsdWUgaXMgdHlwZW9mIFN3YWxEZWZhdWx0IHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXX0=