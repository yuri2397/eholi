import { __awaiter, __decorate, __param } from "tslib";
import { ChangeDetectionStrategy, Component, EventEmitter, Inject, Input, Output } from '@angular/core';
import { dismissOnDestroyToken, fireOnInitToken } from './di';
import { SweetAlert2LoaderService } from './sweetalert2-loader.service';
/**
 * <swal> component. See the README.md for usage.
 *
 * It contains a bunch of @Inputs that have a perfect 1:1 mapping with SweetAlert2 options.
 * Their types are directly coming from SweetAlert2 types defintitions, meaning that ngx-sweetalert2 is tightly coupled
 * to SweetAlert2, but also is type-safe.
 *
 * (?) If you want to use an object that declares the SweetAlert2 options all at once rather than many @Inputs,
 *     take a look at [swalOptions], that lets you pass a full {@link SweetAlertOptions} object.
 *
 * (?) If you are reading the TypeScript source of this component, you may think that it's a lot of code.
 *     Be sure that a lot of this code is types and Angular boilerplate. Compiled and minified code is much smaller.
 *     If you are really concerned about performance and/or don't care about the API and its convenient integration
 *     with Angular (notably change detection and transclusion), you may totally use SweetAlert2 natively as well ;)
 *
 * /!\ Some SweetAlert options aren't @Inputs but @Outputs: onBeforeOpen, onOpen, onClose, onAfterClose and onDestroy
 *     (but without "on*" prefix to respect community standards).
 *     However, preConfirm and inputValidator are still @Inputs because there are not event handlers, there can't be
 *     multiple listeners and we need the values they can/must return.
 */
let SwalComponent = class SwalComponent {
    constructor(sweetAlert2Loader, moduleLevelFireOnInit, moduleLevelDismissOnDestroy) {
        this.sweetAlert2Loader = sweetAlert2Loader;
        this.moduleLevelFireOnInit = moduleLevelFireOnInit;
        this.moduleLevelDismissOnDestroy = moduleLevelDismissOnDestroy;
        /**
         * Emits an event when the modal DOM element has been created.
         * Useful to perform DOM mutations before the modal is shown.
         */
        this.beforeOpen = new EventEmitter();
        /**
         * Emits an event when the modal is shown.
         */
        this.open = new EventEmitter();
        /**
         * Emits an event when the modal DOM is rendered.
         */
        this.render = new EventEmitter();
        /**
         * Emits an event when the modal will be closed.
         * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.
         */
        this.close = new EventEmitter();
        /**
         * Emits an event after the modal had been closed.
         * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.
         */
        this.afterClose = new EventEmitter();
        /**
         * Emits an event after the modal had been closed.
         * The difference between {@link destroy} and {@link afterClose} is that the latter is called for user interactions
         * only (clicks), whereas {@link destroy} is always called, both for user interactions and popup being closed by
         * another popup.
         */
        this.destroy = new EventEmitter();
        /**
         * Emits when the user clicks "Confirm".
         * Bears a value when using "input", resolved "preConfirm", etc.
         *
         * Example:
         *     <swal (confirm)="handleConfirm($event)"></swal>
         *
         *     public handleConfirm(email: string): void {
         *         // ... save user email
         *     }
         */
        this.confirm = new EventEmitter();
        /**
         * Emits when the user clicks "Cancel", or dismisses the modal by any other allowed way.
         * By default, it will emit a string representing the reason for which the SweetAlert has been closed.
         * The reason is `undefined` when {@link dismiss} is called.
         *
         * Example:
         *     <swal (cancel)="handleCancel($event)"></swal>
         *
         *     public handleCancel(reason: DismissReason | undefined): void {
         *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.
         *         // ... do something
         *     }
         */
        this.cancel = new EventEmitter();
        /**
         * This Set retains the properties that have been changed from @Inputs, so we can know precisely
         * what options we have to send to {@link Swal.fire}.
         */
        this.touchedProps = new Set();
        /**
         * A function of signature `(propName: string): void` that adds a given property name to the list of
         * touched properties, ie. {@link touchedProps}.
         */
        this.markTouched = this.touchedProps.add.bind(this.touchedProps);
        /**
         * Is the SweetAlert2 modal represented by this component currently opened?
         */
        this.isCurrentlyShown = false;
    }
    /**
     * An object of SweetAlert2 native options, useful if:
     *  - you don't want to use the @Inputs for practical/philosophical reasons ;
     *  - there are missing @Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.
     *
     * /!\ Please note that setting this property does NOT erase what has been set before unless you specify the
     *     previous properties you want to erase again.
     *     Ie. setting { title: 'Title' } and then { text: 'Text' } will give { title: 'Title', text: 'Text' }.
     *
     * /!\ Be aware that the options defined in this object will override the @Inputs of the same name.
     */
    set swalOptions(options) {
        //=> Update properties
        Object.assign(this, options);
        //=> Mark changed properties as touched
        const touchedKeys = Object.keys(options);
        touchedKeys.forEach(this.markTouched);
    }
    /**
     * Computes the options object that will get passed to SweetAlert2.
     * Only the properties that have been set at least once on this component will be returned.
     * Mostly for internal usage.
     */
    get swalOptions() {
        //=> We will compute the options object based on the option keys that are known to have changed.
        //   That avoids passing a gigantic object to SweetAlert2, making debugging easier and potentially
        //   avoiding side effects.
        return [...this.touchedProps].reduce((obj, key) => (Object.assign(Object.assign({}, obj), { [key]: this[key] })), {});
    }
    set swalVisible(visible) {
        visible ? this.fire() : this.dismiss();
    }
    get swalVisible() {
        return this.isCurrentlyShown;
    }
    /**
     * Angular lifecycle hook.
     * Asks the SweetAlert2 loader service to preload the SweetAlert2 library, so it begins to be loaded only if there
     * is a <swal> component somewhere, and is probably fully loaded when the modal has to be displayed,
     * causing no delay.
     */
    ngOnInit() {
        //=> Preload SweetAlert2 library in case this component is activated.
        this.sweetAlert2Loader.preloadSweetAlertLibrary();
    }
    /**
     * Angular lifecycle hook.
     * Fires the modal, if the component or module is configured to do so.
     */
    ngAfterViewInit() {
        const fireOnInit = this.swalFireOnInit === undefined
            ? this.moduleLevelFireOnInit
            : this.swalFireOnInit;
        fireOnInit && this.fire();
    }
    /**
     * Angular lifecycle hook.
     * Updates the SweetAlert options, and if the modal is opened, asks SweetAlert to render it again.
     */
    ngOnChanges(changes) {
        //=> For each changed @Input that matches a SweetAlert2 option, mark as touched so we can
        //   send it with the next fire() or update() calls.
        Object.keys(changes)
            //=> If the filtering logic becomes more complex here, we can use Swal.isValidParameter
            .filter((key) => !key.startsWith('swal'))
            .forEach(this.markTouched);
        //=> Eventually trigger re-render if the modal is open.
        void this.update();
    }
    /**
     * Angular lifecycle hook.
     * Closes the SweetAlert when the component is destroyed.
     */
    ngOnDestroy() {
        //=> Release the modal if the component is destroyed and if that behaviour is not disabled.
        const dismissOnDestroy = this.swalDismissOnDestroy === undefined
            ? this.moduleLevelDismissOnDestroy
            : this.swalDismissOnDestroy;
        dismissOnDestroy && this.dismiss();
    }
    /**
     * Shows the SweetAlert.
     *
     * Returns the SweetAlert2 promise for convenience and use in code behind templates.
     * Otherwise, (confirm)="myHandler($event)" and (cancel)="myHandler($event)" can be used in templates.
     */
    fire() {
        return __awaiter(this, void 0, void 0, function* () {
            const swal = yield this.sweetAlert2Loader.swal;
            const userOptions = this.swalOptions;
            //=> Build the SweetAlert2 options
            const options = Object.assign(Object.assign({}, userOptions), { 
                //=> Handle modal lifecycle events
                onBeforeOpen: composeHook(userOptions.onBeforeOpen, (modalElement) => {
                    this.beforeOpen.emit({ modalElement });
                }), onOpen: composeHook(userOptions.onOpen, (modalElement) => {
                    this.isCurrentlyShown = true;
                    this.open.emit({ modalElement });
                }), onRender: composeHook(userOptions.onRender, (modalElement) => {
                    this.render.emit({ modalElement });
                }), onClose: composeHook(userOptions.onClose, (modalElement) => {
                    this.isCurrentlyShown = false;
                    this.close.emit({ modalElement });
                }), onAfterClose: composeHook(userOptions.onAfterClose, () => {
                    this.afterClose.emit();
                }), onDestroy: composeHook(userOptions.onDestroy, () => {
                    this.destroy.emit();
                }) });
            //=> Show the Swal! And wait for confirmation or dimissal.
            const result = yield swal.fire(options);
            //=> Emit on (confirm) or (cancel)
            if ('value' in result) {
                this.confirm.emit(result.value);
            }
            else {
                this.cancel.emit(result.dismiss);
            }
            return result;
            function composeHook(userHook, libHook) {
                return (...args) => (libHook(...args), userHook === null || userHook === void 0 ? void 0 : userHook(...args));
            }
        });
    }
    /**
     * Closes the modal, if opened.
     *
     * @param result The value that the modal will resolve with, triggering either (confirm) or (cancel).
     *               If the argument is not passed, (dimiss) will emit `undefined`.
     *               See {@link Swal.close}
     */
    dismiss(result) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isCurrentlyShown)
                return;
            const swal = yield this.sweetAlert2Loader.swal;
            swal.close(result);
        });
    }
    /**
     * Updates SweetAlert2 options while the modal is opened, causing the modal to re-render.
     * If the modal is not opened, the component options will simply be updated and that's it.
     *
     * /!\ Please note that not all SweetAlert2 options are updatable while the modal is opened.
     *
     * @param options
     */
    update(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (options) {
                this.swalOptions = options;
            }
            if (!this.isCurrentlyShown)
                return;
            const swal = yield this.sweetAlert2Loader.swal;
            const allOptions = this.swalOptions;
            const updatableOptions = Object.keys(allOptions)
                .filter(swal.isUpdatableParameter)
                .reduce((obj, key) => (Object.assign(Object.assign({}, obj), { [key]: allOptions[key] })), {});
            swal.update(updatableOptions);
        });
    }
};
SwalComponent.ctorParameters = () => [
    { type: SweetAlert2LoaderService },
    { type: Boolean, decorators: [{ type: Inject, args: [fireOnInitToken,] }] },
    { type: Boolean, decorators: [{ type: Inject, args: [dismissOnDestroyToken,] }] }
];
__decorate([
    Input()
], SwalComponent.prototype, "title", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "titleText", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "text", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "html", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "footer", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "icon", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "iconHtml", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "backdrop", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "toast", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "target", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "input", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "width", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "padding", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "background", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "position", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "grow", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "showClass", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "hideClass", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "customClass", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "timer", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "timerProgressBar", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "animation", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "heightAuto", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "allowOutsideClick", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "allowEscapeKey", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "allowEnterKey", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "stopKeydownPropagation", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "keydownListenerCapture", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "showConfirmButton", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "showCancelButton", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "confirmButtonText", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "cancelButtonText", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "confirmButtonColor", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "cancelButtonColor", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "confirmButtonAriaLabel", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "cancelButtonAriaLabel", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "buttonsStyling", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "reverseButtons", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "focusConfirm", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "focusCancel", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "showCloseButton", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "closeButtonHtml", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "closeButtonAriaLabel", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "showLoaderOnConfirm", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "preConfirm", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "imageUrl", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "imageWidth", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "imageHeight", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "imageAlt", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "inputPlaceholder", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "inputValue", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "inputOptions", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "inputAutoTrim", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "inputAttributes", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "inputValidator", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "validationMessage", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "progressSteps", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "currentProgressStep", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "progressStepsDistance", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "scrollbarPadding", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "swalOptions", null);
__decorate([
    Input()
], SwalComponent.prototype, "swalFireOnInit", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "swalDismissOnDestroy", void 0);
__decorate([
    Input()
], SwalComponent.prototype, "swalVisible", null);
__decorate([
    Output()
], SwalComponent.prototype, "beforeOpen", void 0);
__decorate([
    Output()
], SwalComponent.prototype, "open", void 0);
__decorate([
    Output()
], SwalComponent.prototype, "render", void 0);
__decorate([
    Output()
], SwalComponent.prototype, "close", void 0);
__decorate([
    Output()
], SwalComponent.prototype, "afterClose", void 0);
__decorate([
    Output()
], SwalComponent.prototype, "destroy", void 0);
__decorate([
    Output()
], SwalComponent.prototype, "confirm", void 0);
__decorate([
    Output()
], SwalComponent.prototype, "cancel", void 0);
SwalComponent = __decorate([
    Component({
        // tslint:disable-next-line:component-selector
        selector: 'swal',
        template: '',
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __param(1, Inject(fireOnInitToken)),
    __param(2, Inject(dismissOnDestroyToken))
], SwalComponent);
export { SwalComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3dhbC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Ac3dlZXRhbGVydDIvbmd4LXN3ZWV0YWxlcnQyLyIsInNvdXJjZXMiOlsibGliL3N3YWwuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ1ksdUJBQXVCLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUM5RSxNQUFNLEVBQ1QsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLHFCQUFxQixFQUFFLGVBQWUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUU5RCxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUV4RTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW1CRztBQU9ILElBQWEsYUFBYSxHQUExQixNQUFhLGFBQWE7SUFxTnRCLFlBQ3FCLGlCQUEyQyxFQUNsQixxQkFBOEIsRUFDeEIsMkJBQW9DO1FBRm5FLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBMEI7UUFDbEIsMEJBQXFCLEdBQXJCLHFCQUFxQixDQUFTO1FBQ3hCLGdDQUEyQixHQUEzQiwyQkFBMkIsQ0FBUztRQTVGeEY7OztXQUdHO1FBRWEsZUFBVSxHQUFHLElBQUksWUFBWSxFQUEwQixDQUFDO1FBRXhFOztXQUVHO1FBRWEsU0FBSSxHQUFHLElBQUksWUFBWSxFQUFvQixDQUFDO1FBRTVEOztXQUVHO1FBRWEsV0FBTSxHQUFHLElBQUksWUFBWSxFQUFzQixDQUFDO1FBRWhFOzs7V0FHRztRQUVhLFVBQUssR0FBRyxJQUFJLFlBQVksRUFBcUIsQ0FBQztRQUU5RDs7O1dBR0c7UUFFYSxlQUFVLEdBQUcsSUFBSSxZQUFZLEVBQVEsQ0FBQztRQUV0RDs7Ozs7V0FLRztRQUVhLFlBQU8sR0FBRyxJQUFJLFlBQVksRUFBUSxDQUFDO1FBRW5EOzs7Ozs7Ozs7O1dBVUc7UUFFYSxZQUFPLEdBQUcsSUFBSSxZQUFZLEVBQU8sQ0FBQztRQUVsRDs7Ozs7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IjpbImltcG9ydCB7XG4gICAgQWZ0ZXJWaWV3SW5pdCwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbmplY3QsIElucHV0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgT25Jbml0LFxuICAgIE91dHB1dCwgU2ltcGxlQ2hhbmdlc1xufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCBTd2FsLCB7IFN3ZWV0QWxlcnRPcHRpb25zLCBTd2VldEFsZXJ0UmVzdWx0LCBTd2VldEFsZXJ0VXBkYXRhYmxlUGFyYW1ldGVycyB9IGZyb20gJ3N3ZWV0YWxlcnQyJztcbmltcG9ydCB7IGRpc21pc3NPbkRlc3Ryb3lUb2tlbiwgZmlyZU9uSW5pdFRva2VuIH0gZnJvbSAnLi9kaSc7XG5pbXBvcnQgKiBhcyBldmVudHMgZnJvbSAnLi9zd2FsLWV2ZW50cyc7XG5pbXBvcnQgeyBTd2VldEFsZXJ0MkxvYWRlclNlcnZpY2UgfSBmcm9tICcuL3N3ZWV0YWxlcnQyLWxvYWRlci5zZXJ2aWNlJztcblxuLyoqXG4gKiA8c3dhbD4gY29tcG9uZW50LiBTZWUgdGhlIFJFQURNRS5tZCBmb3IgdXNhZ2UuXG4gKlxuICogSXQgY29udGFpbnMgYSBidW5jaCBvZiBASW5wdXRzIHRoYXQgaGF2ZSBhIHBlcmZlY3QgMToxIG1hcHBpbmcgd2l0aCBTd2VldEFsZXJ0MiBvcHRpb25zLlxuICogVGhlaXIgdHlwZXMgYXJlIGRpcmVjdGx5IGNvbWluZyBmcm9tIFN3ZWV0QWxlcnQyIHR5cGVzIGRlZmludGl0aW9ucywgbWVhbmluZyB0aGF0IG5neC1zd2VldGFsZXJ0MiBpcyB0aWdodGx5IGNvdXBsZWRcbiAqIHRvIFN3ZWV0QWxlcnQyLCBidXQgYWxzbyBpcyB0eXBlLXNhZmUuXG4gKlxuICogKD8pIElmIHlvdSB3YW50IHRvIHVzZSBhbiBvYmplY3QgdGhhdCBkZWNsYXJlcyB0aGUgU3dlZXRBbGVydDIgb3B0aW9ucyBhbGwgYXQgb25jZSByYXRoZXIgdGhhbiBtYW55IEBJbnB1dHMsXG4gKiAgICAgdGFrZSBhIGxvb2sgYXQgW3N3YWxPcHRpb25zXSwgdGhhdCBsZXRzIHlvdSBwYXNzIGEgZnVsbCB7QGxpbmsgU3dlZXRBbGVydE9wdGlvbnN9IG9iamVjdC5cbiAqXG4gKiAoPykgSWYgeW91IGFyZSByZWFkaW5nIHRoZSBUeXBlU2NyaXB0IHNvdXJjZSBvZiB0aGlzIGNvbXBvbmVudCwgeW91IG1heSB0aGluayB0aGF0IGl0J3MgYSBsb3Qgb2YgY29kZS5cbiAqICAgICBCZSBzdXJlIHRoYXQgYSBsb3Qgb2YgdGhpcyBjb2RlIGlzIHR5cGVzIGFuZCBBbmd1bGFyIGJvaWxlcnBsYXRlLiBDb21waWxlZCBhbmQgbWluaWZpZWQgY29kZSBpcyBtdWNoIHNtYWxsZXIuXG4gKiAgICAgSWYgeW91IGFyZSByZWFsbHkgY29uY2VybmVkIGFib3V0IHBlcmZvcm1hbmNlIGFuZC9vciBkb24ndCBjYXJlIGFib3V0IHRoZSBBUEkgYW5kIGl0cyBjb252ZW5pZW50IGludGVncmF0aW9uXG4gKiAgICAgd2l0aCBBbmd1bGFyIChub3RhYmx5IGNoYW5nZSBkZXRlY3Rpb24gYW5kIHRyYW5zY2x1c2lvbiksIHlvdSBtYXkgdG90YWxseSB1c2UgU3dlZXRBbGVydDIgbmF0aXZlbHkgYXMgd2VsbCA7KVxuICpcbiAqIC8hXFwgU29tZSBTd2VldEFsZXJ0IG9wdGlvbnMgYXJlbid0IEBJbnB1dHMgYnV0IEBPdXRwdXRzOiBvbkJlZm9yZU9wZW4sIG9uT3Blbiwgb25DbG9zZSwgb25BZnRlckNsb3NlIGFuZCBvbkRlc3Ryb3lcbiAqICAgICAoYnV0IHdpdGhvdXQgXCJvbipcIiBwcmVmaXggdG8gcmVzcGVjdCBjb21tdW5pdHkgc3RhbmRhcmRzKS5cbiAqICAgICBIb3dldmVyLCBwcmVDb25maXJtIGFuZCBpbnB1dFZhbGlkYXRvciBhcmUgc3RpbGwgQElucHV0cyBiZWNhdXNlIHRoZXJlIGFyZSBub3QgZXZlbnQgaGFuZGxlcnMsIHRoZXJlIGNhbid0IGJlXG4gKiAgICAgbXVsdGlwbGUgbGlzdGVuZXJzIGFuZCB3ZSBuZWVkIHRoZSB2YWx1ZXMgdGhleSBjYW4vbXVzdCByZXR1cm4uXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpjb21wb25lbnQtc2VsZWN0b3JcbiAgICBzZWxlY3RvcjogJ3N3YWwnLFxuICAgIHRlbXBsYXRlOiAnJyxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBTd2FsQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBBZnRlclZpZXdJbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG4gICAgQElucHV0KCkgcHVibGljIHRpdGxlOiBTd2VldEFsZXJ0T3B0aW9uc1sndGl0bGUnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdGl0bGVUZXh0OiBTd2VldEFsZXJ0T3B0aW9uc1sndGl0bGVUZXh0J107XG4gICAgQElucHV0KCkgcHVibGljIHRleHQ6IFN3ZWV0QWxlcnRPcHRpb25zWyd0ZXh0J107XG4gICAgQElucHV0KCkgcHVibGljIGh0bWw6IFN3ZWV0QWxlcnRPcHRpb25zWydodG1sJ107XG4gICAgQElucHV0KCkgcHVibGljIGZvb3RlcjogU3dlZXRBbGVydE9wdGlvbnNbJ2Zvb3RlciddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpY29uOiBTd2VldEFsZXJ0T3B0aW9uc1snaWNvbiddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpY29uSHRtbDogU3dlZXRBbGVydE9wdGlvbnNbJ2ljb25IdG1sJ107XG4gICAgQElucHV0KCkgcHVibGljIGJhY2tkcm9wOiBTd2VldEFsZXJ0T3B0aW9uc1snYmFja2Ryb3AnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdG9hc3Q6IFN3ZWV0QWxlcnRPcHRpb25zWyd0b2FzdCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB0YXJnZXQ6IFN3ZWV0QWxlcnRPcHRpb25zWyd0YXJnZXQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXQ6IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB3aWR0aDogU3dlZXRBbGVydE9wdGlvbnNbJ3dpZHRoJ107XG4gICAgQElucHV0KCkgcHVibGljIHBhZGRpbmc6IFN3ZWV0QWxlcnRPcHRpb25zWydwYWRkaW5nJ107XG4gICAgQElucHV0KCkgcHVibGljIGJhY2tncm91bmQ6IFN3ZWV0QWxlcnRPcHRpb25zWydiYWNrZ3JvdW5kJ107XG4gICAgQElucHV0KCkgcHVibGljIHBvc2l0aW9uOiBTd2VldEFsZXJ0T3B0aW9uc1sncG9zaXRpb24nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgZ3JvdzogU3dlZXRBbGVydE9wdGlvbnNbJ2dyb3cnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgc2hvd0NsYXNzOiBTd2VldEFsZXJ0T3B0aW9uc1snc2hvd0NsYXNzJ107XG4gICAgQElucHV0KCkgcHVibGljIGhpZGVDbGFzczogU3dlZXRBbGVydE9wdGlvbnNbJ2hpZGVDbGFzcyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjdXN0b21DbGFzczogU3dlZXRBbGVydE9wdGlvbnNbJ2N1c3RvbUNsYXNzJ107XG4gICAgQElucHV0KCkgcHVibGljIHRpbWVyOiBTd2VldEFsZXJ0T3B0aW9uc1sndGltZXInXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdGltZXJQcm9ncmVzc0JhcjogU3dlZXRBbGVydE9wdGlvbnNbJ3RpbWVyUHJvZ3Jlc3NCYXInXTtcbiAgICAvKiogQGRlcHJlY2F0ZWQgVXNlIHNob3dDbGFzcyBhbmQgaGlkZUNsYXNzIGluc3RlYWQgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgYW5pbWF0aW9uOiBTd2VldEFsZXJ0T3B0aW9uc1snYW5pbWF0aW9uJ107XG4gICAgQElucHV0KCkgcHVibGljIGhlaWdodEF1dG86IFN3ZWV0QWxlcnRPcHRpb25zWydoZWlnaHRBdXRvJ107XG4gICAgQElucHV0KCkgcHVibGljIGFsbG93T3V0c2lkZUNsaWNrOiBTd2VldEFsZXJ0T3B0aW9uc1snYWxsb3dPdXRzaWRlQ2xpY2snXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgYWxsb3dFc2NhcGVLZXk6IFN3ZWV0QWxlcnRPcHRpb25zWydhbGxvd0VzY2FwZUtleSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBhbGxvd0VudGVyS2V5OiBTd2VldEFsZXJ0T3B0aW9uc1snYWxsb3dFbnRlcktleSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzdG9wS2V5ZG93blByb3BhZ2F0aW9uOiBTd2VldEFsZXJ0T3B0aW9uc1snc3RvcEtleWRvd25Qcm9wYWdhdGlvbiddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBrZXlkb3duTGlzdGVuZXJDYXB0dXJlOiBTd2VldEFsZXJ0T3B0aW9uc1sna2V5ZG93bkxpc3RlbmVyQ2FwdHVyZSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzaG93Q29uZmlybUJ1dHRvbjogU3dlZXRBbGVydE9wdGlvbnNbJ3Nob3dDb25maXJtQnV0dG9uJ107XG4gICAgQElucHV0KCkgcHVibGljIHNob3dDYW5jZWxCdXR0b246IFN3ZWV0QWxlcnRPcHRpb25zWydzaG93Q2FuY2VsQnV0dG9uJ107XG4gICAgQElucHV0KCkgcHVibGljIGNvbmZpcm1CdXR0b25UZXh0OiBTd2VldEFsZXJ0T3B0aW9uc1snY29uZmlybUJ1dHRvblRleHQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY2FuY2VsQnV0dG9uVGV4dDogU3dlZXRBbGVydE9wdGlvbnNbJ2NhbmNlbEJ1dHRvblRleHQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY29uZmlybUJ1dHRvbkNvbG9yOiBTd2VldEFsZXJ0T3B0aW9uc1snY29uZmlybUJ1dHRvbkNvbG9yJ107XG4gICAgQElucHV0KCkgcHVibGljIGNhbmNlbEJ1dHRvbkNvbG9yOiBTd2VldEFsZXJ0T3B0aW9uc1snY2FuY2VsQnV0dG9uQ29sb3InXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY29uZmlybUJ1dHRvbkFyaWFMYWJlbDogU3dlZXRBbGVydE9wdGlvbnNbJ2NvbmZpcm1CdXR0b25BcmlhTGFiZWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY2FuY2VsQnV0dG9uQXJpYUxhYmVsOiBTd2VldEFsZXJ0T3B0aW9uc1snY2FuY2VsQnV0dG9uQXJpYUxhYmVsJ107XG4gICAgQElucHV0KCkgcHVibGljIGJ1dHRvbnNTdHlsaW5nOiBTd2VldEFsZXJ0T3B0aW9uc1snYnV0dG9uc1N0eWxpbmcnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgcmV2ZXJzZUJ1dHRvbnM6IFN3ZWV0QWxlcnRPcHRpb25zWydyZXZlcnNlQnV0dG9ucyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBmb2N1c0NvbmZpcm06IFN3ZWV0QWxlcnRPcHRpb25zWydmb2N1c0NvbmZpcm0nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgZm9jdXNDYW5jZWw6IFN3ZWV0QWxlcnRPcHRpb25zWydmb2N1c0NhbmNlbCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzaG93Q2xvc2VCdXR0b246IFN3ZWV0QWxlcnRPcHRpb25zWydzaG93Q2xvc2VCdXR0b24nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY2xvc2VCdXR0b25IdG1sOiBTd2VldEFsZXJ0T3B0aW9uc1snY2xvc2VCdXR0b25IdG1sJ107XG4gICAgQElucHV0KCkgcHVibGljIGNsb3NlQnV0dG9uQXJpYUxhYmVsOiBTd2VldEFsZXJ0T3B0aW9uc1snY2xvc2VCdXR0b25BcmlhTGFiZWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgc2hvd0xvYWRlck9uQ29uZmlybTogU3dlZXRBbGVydE9wdGlvbnNbJ3Nob3dMb2FkZXJPbkNvbmZpcm0nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgcHJlQ29uZmlybTogU3dlZXRBbGVydE9wdGlvbnNbJ3ByZUNvbmZpcm0nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW1hZ2VVcmw6IFN3ZWV0QWxlcnRPcHRpb25zWydpbWFnZVVybCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbWFnZVdpZHRoOiBTd2VldEFsZXJ0T3B0aW9uc1snaW1hZ2VXaWR0aCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbWFnZUhlaWdodDogU3dlZXRBbGVydE9wdGlvbnNbJ2ltYWdlSGVpZ2h0J107XG4gICAgQElucHV0KCkgcHVibGljIGltYWdlQWx0OiBTd2VldEFsZXJ0T3B0aW9uc1snaW1hZ2VBbHQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXRQbGFjZWhvbGRlcjogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0UGxhY2Vob2xkZXInXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXRWYWx1ZTogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0VmFsdWUnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXRPcHRpb25zOiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXRPcHRpb25zJ107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0QXV0b1RyaW06IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dEF1dG9UcmltJ107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0QXR0cmlidXRlczogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0QXR0cmlidXRlcyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbnB1dFZhbGlkYXRvcjogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0VmFsaWRhdG9yJ107XG4gICAgQElucHV0KCkgcHVibGljIHZhbGlkYXRpb25NZXNzYWdlOiBTd2VldEFsZXJ0T3B0aW9uc1sndmFsaWRhdGlvbk1lc3NhZ2UnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgcHJvZ3Jlc3NTdGVwczogU3dlZXRBbGVydE9wdGlvbnNbJ3Byb2dyZXNzU3RlcHMnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY3VycmVudFByb2dyZXNzU3RlcDogU3dlZXRBbGVydE9wdGlvbnNbJ2N1cnJlbnRQcm9ncmVzc1N0ZXAnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgcHJvZ3Jlc3NTdGVwc0Rpc3RhbmNlOiBTd2VldEFsZXJ0T3B0aW9uc1sncHJvZ3Jlc3NTdGVwc0Rpc3RhbmNlJ107XG4gICAgQElucHV0KCkgcHVibGljIHNjcm9sbGJhclBhZGRpbmc6IFN3ZWV0QWxlcnRPcHRpb25zWydzY3JvbGxiYXJQYWRkaW5nJ107XG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3Qgb2YgU3dlZXRBbGVydDIgbmF0aXZlIG9wdGlvbnMsIHVzZWZ1bCBpZjpcbiAgICAgKiAgLSB5b3UgZG9uJ3Qgd2FudCB0byB1c2UgdGhlIEBJbnB1dHMgZm9yIHByYWN0aWNhbC9waGlsb3NvcGhpY2FsIHJlYXNvbnMgO1xuICAgICAqICAtIHRoZXJlIGFyZSBtaXNzaW5nIEBJbnB1dHMgYmVjYXVzZSBuZ3gtc3dlZXRhbGVydDIgaXNuJ3QgdXAtdG8tZGF0ZSB3aXRoIFN3ZWV0QWxlcnQyJ3MgbGF0ZXN0IGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiAvIVxcIFBsZWFzZSBub3RlIHRoYXQgc2V0dGluZyB0aGlzIHByb3BlcnR5IGRvZXMgTk9UIGVyYXNlIHdoYXQgaGFzIGJlZW4gc2V0IGJlZm9yZSB1bmxlc3MgeW91IHNwZWNpZnkgdGhlXG4gICAgICogICAgIHByZXZpb3VzIHByb3BlcnRpZXMgeW91IHdhbnQgdG8gZXJhc2UgYWdhaW4uXG4gICAgICogICAgIEllLiBzZXR0aW5nIHsgdGl0bGU6ICdUaXRsZScgfSBhbmQgdGhlbiB7IHRleHQ6ICdUZXh0JyB9IHdpbGwgZ2l2ZSB7IHRpdGxlOiAnVGl0bGUnLCB0ZXh0OiAnVGV4dCcgfS5cbiAgICAgKlxuICAgICAqIC8hXFwgQmUgYXdhcmUgdGhhdCB0aGUgb3B0aW9ucyBkZWZpbmVkIGluIHRoaXMgb2JqZWN0IHdpbGwgb3ZlcnJpZGUgdGhlIEBJbnB1dHMgb2YgdGhlIHNhbWUgbmFtZS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgc3dhbE9wdGlvbnMob3B0aW9uczogU3dlZXRBbGVydE9wdGlvbnMpIHtcbiAgICAgICAgLy89PiBVcGRhdGUgcHJvcGVydGllc1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vPT4gTWFyayBjaGFuZ2VkIHByb3BlcnRpZXMgYXMgdG91Y2hlZFxuICAgICAgICBjb25zdCB0b3VjaGVkS2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpIGFzIEFycmF5PGtleW9mIFN3ZWV0QWxlcnRPcHRpb25zPjtcbiAgICAgICAgdG91Y2hlZEtleXMuZm9yRWFjaCh0aGlzLm1hcmtUb3VjaGVkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgb3B0aW9ucyBvYmplY3QgdGhhdCB3aWxsIGdldCBwYXNzZWQgdG8gU3dlZXRBbGVydDIuXG4gICAgICogT25seSB0aGUgcHJvcGVydGllcyB0aGF0IGhhdmUgYmVlbiBzZXQgYXQgbGVhc3Qgb25jZSBvbiB0aGlzIGNvbXBvbmVudCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIE1vc3RseSBmb3IgaW50ZXJuYWwgdXNhZ2UuXG4gICAgICovXG4gICAgcHVibGljIGdldCBzd2FsT3B0aW9ucygpOiBTd2VldEFsZXJ0T3B0aW9ucyB7XG4gICAgICAgIC8vPT4gV2Ugd2lsbCBjb21wdXRlIHRoZSBvcHRpb25zIG9iamVjdCBiYXNlZCBvbiB0aGUgb3B0aW9uIGtleXMgdGhhdCBhcmUga25vd24gdG8gaGF2ZSBjaGFuZ2VkLlxuICAgICAgICAvLyAgIFRoYXQgYXZvaWRzIHBhc3NpbmcgYSBnaWdhbnRpYyBvYmplY3QgdG8gU3dlZXRBbGVydDIsIG1ha2luZyBkZWJ1Z2dpbmcgZWFzaWVyIGFuZCBwb3RlbnRpYWxseVxuICAgICAgICAvLyAgIGF2b2lkaW5nIHNpZGUgZWZmZWN0cy5cbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLnRvdWNoZWRQcm9wc10ucmVkdWNlPFN3ZWV0QWxlcnRPcHRpb25zPihcbiAgICAgICAgICAgIChvYmosIGtleSkgPT4gKHsgLi4ub2JqLCBba2V5XTogdGhpc1trZXkgYXMga2V5b2YgdGhpc10gfSksXG4gICAgICAgICAgICB7fSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBmaXJlIHRoZSBtb2RhbCBhcyBzb29uIGFzIHRoZSA8c3dhbD4gY29tcG9uZW50IGlzIGNyZWF0ZWQgYW5kIGluaXRpYWxpemVkIGluIHRoZSB2aWV3LlxuICAgICAqIFdoZW4gbGVmdCB1bmRlZmluZWQgKGRlZmF1bHQpLCB0aGUgdmFsdWUgd2lsbCBiZSBpbmhlcml0ZWQgZnJvbSB0aGUgbW9kdWxlIGNvbmZpZ3VyYXRpb24sIHdoaWNoIGlzIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgICA8c3dhbCAqbmdJZj1cImVycm9yXCIgW3RpdGxlXT1cImVycm9yLnRpdGxlXCIgW3RleHRdPVwiZXJyb3IudGV4dFwiIGljb249XCJlcnJvclwiIFtzd2FsRmlyZU9uSW5pdF09XCJ0cnVlXCI+PC9zd2FsPlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHN3YWxGaXJlT25Jbml0PzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gZGlzbWlzcyB0aGUgbW9kYWwgd2hlbiB0aGUgPHN3YWw+IGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgYnkgQW5ndWxhciAoZm9yIGFueSByZWFzb24pIG9yIG5vdC5cbiAgICAgKiBXaGVuIGxlZnQgdW5kZWZpbmVkIChkZWZhdWx0KSwgdGhlIHZhbHVlIHdpbGwgYmUgaW5oZXJpdGVkIGZyb20gdGhlIG1vZHVsZSBjb25maWd1cmF0aW9uLCB3aGljaCBpcyBgdHJ1ZWAuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc3dhbERpc21pc3NPbkRlc3Ryb3k/OiBib29sZWFuO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IHN3YWxWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pIHtcbiAgICAgICAgdmlzaWJsZSA/IHRoaXMuZmlyZSgpIDogdGhpcy5kaXNtaXNzKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBzd2FsVmlzaWJsZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDdXJyZW50bHlTaG93bjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSBtb2RhbCBET00gZWxlbWVudCBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAqIFVzZWZ1bCB0byBwZXJmb3JtIERPTSBtdXRhdGlvbnMgYmVmb3JlIHRoZSBtb2RhbCBpcyBzaG93bi5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgYmVmb3JlT3BlbiA9IG5ldyBFdmVudEVtaXR0ZXI8ZXZlbnRzLkJlZm9yZU9wZW5FdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIG1vZGFsIGlzIHNob3duLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZWFkb25seSBvcGVuID0gbmV3IEV2ZW50RW1pdHRlcjxldmVudHMuT3BlbkV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgd2hlbiB0aGUgbW9kYWwgRE9NIGlzIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZWFkb25seSByZW5kZXIgPSBuZXcgRXZlbnRFbWl0dGVyPGV2ZW50cy5SZW5kZXJFdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIG1vZGFsIHdpbGwgYmUgY2xvc2VkLlxuICAgICAqIElmIHlvdSBqdXN0IHdhbnQgdG8ga25vdyB3aGVuIHRoZSB1c2VyIGRpc21pc3NlZCB0aGUgbW9kYWwsIHByZWZlciB0aGUgaGlnaGVyLWxldmVsIChjYW5jZWwpIG91dHB1dC5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgY2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyPGV2ZW50cy5DbG9zZUV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgYWZ0ZXIgdGhlIG1vZGFsIGhhZCBiZWVuIGNsb3NlZC5cbiAgICAgKiBJZiB5b3UganVzdCB3YW50IHRvIGtub3cgd2hlbiB0aGUgdXNlciBkaXNtaXNzZWQgdGhlIG1vZGFsLCBwcmVmZXIgdGhlIGhpZ2hlci1sZXZlbCAoY2FuY2VsKSBvdXRwdXQuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IGFmdGVyQ2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBhZnRlciB0aGUgbW9kYWwgaGFkIGJlZW4gY2xvc2VkLlxuICAgICAqIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4ge0BsaW5rIGRlc3Ryb3l9IGFuZCB7QGxpbmsgYWZ0ZXJDbG9zZX0gaXMgdGhhdCB0aGUgbGF0dGVyIGlzIGNhbGxlZCBmb3IgdXNlciBpbnRlcmFjdGlvbnNcbiAgICAgKiBvbmx5IChjbGlja3MpLCB3aGVyZWFzIHtAbGluayBkZXN0cm95fSBpcyBhbHdheXMgY2FsbGVkLCBib3RoIGZvciB1c2VyIGludGVyYWN0aW9ucyBhbmQgcG9wdXAgYmVpbmcgY2xvc2VkIGJ5XG4gICAgICogYW5vdGhlciBwb3B1cC5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgZGVzdHJveSA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIFwiQ29uZmlybVwiLlxuICAgICAqIEJlYXJzIGEgdmFsdWUgd2hlbiB1c2luZyBcImlucHV0XCIsIHJlc29sdmVkIFwicHJlQ29uZmlybVwiLCBldGMuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgICA8c3dhbCAoY29uZmlybSk9XCJoYW5kbGVDb25maXJtKCRldmVudClcIj48L3N3YWw+XG4gICAgICpcbiAgICAgKiAgICAgcHVibGljIGhhbmRsZUNvbmZpcm0oZW1haWw6IHN0cmluZyk6IHZvaWQge1xuICAgICAqICAgICAgICAgLy8gLi4uIHNhdmUgdXNlciBlbWFpbFxuICAgICAqICAgICB9XG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IGNvbmZpcm0gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIFwiQ2FuY2VsXCIsIG9yIGRpc21pc3NlcyB0aGUgbW9kYWwgYnkgYW55IG90aGVyIGFsbG93ZWQgd2F5LlxuICAgICAqIEJ5IGRlZmF1bHQsIGl0IHdpbGwgZW1pdCBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHJlYXNvbiBmb3Igd2hpY2ggdGhlIFN3ZWV0QWxlcnQgaGFzIGJlZW4gY2xvc2VkLlxuICAgICAqIFRoZSByZWFzb24gaXMgYHVuZGVmaW5lZGAgd2hlbiB7QGxpbmsgZGlzbWlzc30gaXMgY2FsbGVkLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgICAgPHN3YWwgKGNhbmNlbCk9XCJoYW5kbGVDYW5jZWwoJGV2ZW50KVwiPjwvc3dhbD5cbiAgICAgKlxuICAgICAqICAgICBwdWJsaWMgaGFuZGxlQ2FuY2VsKHJlYXNvbjogRGlzbWlzc1JlYXNvbiB8IHVuZGVmaW5lZCk6IHZvaWQge1xuICAgICAqICAgICAgICAgLy8gcmVhc29uIGNhbiBiZSAnY2FuY2VsJywgJ292ZXJsYXknLCAnY2xvc2UnLCAndGltZXInIG9yIHVuZGVmaW5lZC5cbiAgICAgKiAgICAgICAgIC8vIC4uLiBkbyBzb21ldGhpbmdcbiAgICAgKiAgICAgfVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZWFkb25seSBjYW5jZWwgPSBuZXcgRXZlbnRFbWl0dGVyPFN3YWwuRGlzbWlzc1JlYXNvbiB8IHVuZGVmaW5lZD4oKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgU2V0IHJldGFpbnMgdGhlIHByb3BlcnRpZXMgdGhhdCBoYXZlIGJlZW4gY2hhbmdlZCBmcm9tIEBJbnB1dHMsIHNvIHdlIGNhbiBrbm93IHByZWNpc2VseVxuICAgICAqIHdoYXQgb3B0aW9ucyB3ZSBoYXZlIHRvIHNlbmQgdG8ge0BsaW5rIFN3YWwuZmlyZX0uXG4gICAgICovXG4gICAgcHJpdmF0ZSByZWFkb25seSB0b3VjaGVkUHJvcHMgPSBuZXcgU2V0PGtleW9mIFN3ZWV0QWxlcnRPcHRpb25zPigpO1xuXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiBvZiBzaWduYXR1cmUgYChwcm9wTmFtZTogc3RyaW5nKTogdm9pZGAgdGhhdCBhZGRzIGEgZ2l2ZW4gcHJvcGVydHkgbmFtZSB0byB0aGUgbGlzdCBvZlxuICAgICAqIHRvdWNoZWQgcHJvcGVydGllcywgaWUuIHtAbGluayB0b3VjaGVkUHJvcHN9LlxuICAgICAqL1xuICAgIHByaXZhdGUgcmVhZG9ubHkgbWFya1RvdWNoZWQgPSB0aGlzLnRvdWNoZWRQcm9wcy5hZGQuYmluZCh0aGlzLnRvdWNoZWRQcm9wcyk7XG5cbiAgICAvKipcbiAgICAgKiBJcyB0aGUgU3dlZXRBbGVydDIgbW9kYWwgcmVwcmVzZW50ZWQgYnkgdGhpcyBjb21wb25lbnQgY3VycmVudGx5IG9wZW5lZD9cbiAgICAgKi9cbiAgICBwcml2YXRlIGlzQ3VycmVudGx5U2hvd24gPSBmYWxzZTtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBzd2VldEFsZXJ0MkxvYWRlcjogU3dlZXRBbGVydDJMb2FkZXJTZXJ2aWNlLFxuICAgICAgICBASW5qZWN0KGZpcmVPbkluaXRUb2tlbikgcHJpdmF0ZSByZWFkb25seSBtb2R1bGVMZXZlbEZpcmVPbkluaXQ6IGJvb2xlYW4sXG4gICAgICAgIEBJbmplY3QoZGlzbWlzc09uRGVzdHJveVRva2VuKSBwcml2YXRlIHJlYWRvbmx5IG1vZHVsZUxldmVsRGlzbWlzc09uRGVzdHJveTogYm9vbGVhbikge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuZ3VsYXIgbGlmZWN5Y2xlIGhvb2suXG4gICAgICogQXNrcyB0aGUgU3dlZXRBbGVydDIgbG9hZGVyIHNlcnZpY2UgdG8gcHJlbG9hZCB0aGUgU3dlZXRBbGVydDIgbGlicmFyeSwgc28gaXQgYmVnaW5zIHRvIGJlIGxvYWRlZCBvbmx5IGlmIHRoZXJlXG4gICAgICogaXMgYSA8c3dhbD4gY29tcG9uZW50IHNvbWV3aGVyZSwgYW5kIGlzIHByb2JhYmx5IGZ1bGx5IGxvYWRlZCB3aGVuIHRoZSBtb2RhbCBoYXMgdG8gYmUgZGlzcGxheWVkLFxuICAgICAqIGNhdXNpbmcgbm8gZGVsYXkuXG4gICAgICovXG4gICAgcHVibGljIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICAvLz0+IFByZWxvYWQgU3dlZXRBbGVydDIgbGlicmFyeSBpbiBjYXNlIHRoaXMgY29tcG9uZW50IGlzIGFjdGl2YXRlZC5cbiAgICAgICAgdGhpcy5zd2VldEFsZXJ0MkxvYWRlci5wcmVsb2FkU3dlZXRBbGVydExpYnJhcnkoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmd1bGFyIGxpZmVjeWNsZSBob29rLlxuICAgICAqIEZpcmVzIHRoZSBtb2RhbCwgaWYgdGhlIGNvbXBvbmVudCBvciBtb2R1bGUgaXMgY29uZmlndXJlZCB0byBkbyBzby5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICBjb25zdCBmaXJlT25Jbml0ID0gdGhpcy5zd2FsRmlyZU9uSW5pdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHRoaXMubW9kdWxlTGV2ZWxGaXJlT25Jbml0XG4gICAgICAgICAgICA6IHRoaXMuc3dhbEZpcmVPbkluaXQ7XG5cbiAgICAgICAgZmlyZU9uSW5pdCAmJiB0aGlzLmZpcmUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmd1bGFyIGxpZmVjeWNsZSBob29rLlxuICAgICAqIFVwZGF0ZXMgdGhlIFN3ZWV0QWxlcnQgb3B0aW9ucywgYW5kIGlmIHRoZSBtb2RhbCBpcyBvcGVuZWQsIGFza3MgU3dlZXRBbGVydCB0byByZW5kZXIgaXQgYWdhaW4uXG4gICAgICovXG4gICAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICAgICAgLy89PiBGb3IgZWFjaCBjaGFuZ2VkIEBJbnB1dCB0aGF0IG1hdGNoZXMgYSBTd2VldEFsZXJ0MiBvcHRpb24sIG1hcmsgYXMgdG91Y2hlZCBzbyB3ZSBjYW5cbiAgICAgICAgLy8gICBzZW5kIGl0IHdpdGggdGhlIG5leHQgZmlyZSgpIG9yIHVwZGF0ZSgpIGNhbGxzLlxuICAgICAgICBPYmplY3Qua2V5cyhjaGFuZ2VzKVxuICAgICAgICAgICAgLy89PiBJZiB0aGUgZmlsdGVyaW5nIGxvZ2ljIGJlY29tZXMgbW9yZSBjb21wbGV4IGhlcmUsIHdlIGNhbiB1c2UgU3dhbC5pc1ZhbGlkUGFyYW1ldGVyXG4gICAgICAgICAgICAuZmlsdGVyKChrZXkpOiBrZXkgaXMga2V5b2YgU3dlZXRBbGVydE9wdGlvbnMgPT4gIWtleS5zdGFydHNXaXRoKCdzd2FsJykpXG4gICAgICAgICAgICAuZm9yRWFjaCh0aGlzLm1hcmtUb3VjaGVkKTtcblxuICAgICAgICAvLz0+IEV2ZW50dWFsbHkgdHJpZ2dlciByZS1yZW5kZXIgaWYgdGhlIG1vZGFsIGlzIG9wZW4uXG4gICAgICAgIHZvaWQgdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmd1bGFyIGxpZmVjeWNsZSBob29rLlxuICAgICAqIENsb3NlcyB0aGUgU3dlZXRBbGVydCB3aGVuIHRoZSBjb21wb25lbnQgaXMgZGVzdHJveWVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgLy89PiBSZWxlYXNlIHRoZSBtb2RhbCBpZiB0aGUgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBhbmQgaWYgdGhhdCBiZWhhdmlvdXIgaXMgbm90IGRpc2FibGVkLlxuICAgICAgICBjb25zdCBkaXNtaXNzT25EZXN0cm95ID0gdGhpcy5zd2FsRGlzbWlzc09uRGVzdHJveSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHRoaXMubW9kdWxlTGV2ZWxEaXNtaXNzT25EZXN0cm95XG4gICAgICAgICAgICA6IHRoaXMuc3dhbERpc21pc3NPbkRlc3Ryb3k7XG5cbiAgICAgICAgZGlzbWlzc09uRGVzdHJveSAmJiB0aGlzLmRpc21pc3MoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyB0aGUgU3dlZXRBbGVydC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgdGhlIFN3ZWV0QWxlcnQyIHByb21pc2UgZm9yIGNvbnZlbmllbmNlIGFuZCB1c2UgaW4gY29kZSBiZWhpbmQgdGVtcGxhdGVzLlxuICAgICAqIE90aGVyd2lzZSwgKGNvbmZpcm0pPVwibXlIYW5kbGVyKCRldmVudClcIiBhbmQgKGNhbmNlbCk9XCJteUhhbmRsZXIoJGV2ZW50KVwiIGNhbiBiZSB1c2VkIGluIHRlbXBsYXRlcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZmlyZSgpOiBQcm9taXNlPFN3ZWV0QWxlcnRSZXN1bHQ+IHtcbiAgICAgICAgY29uc3Qgc3dhbCA9IGF3YWl0IHRoaXMuc3dlZXRBbGVydDJMb2FkZXIuc3dhbDtcblxuICAgICAgICBjb25zdCB1c2VyT3B0aW9ucyA9IHRoaXMuc3dhbE9wdGlvbnM7XG5cbiAgICAgICAgLy89PiBCdWlsZCB0aGUgU3dlZXRBbGVydDIgb3B0aW9uc1xuICAgICAgICBjb25zdCBvcHRpb25zOiBTd2VldEFsZXJ0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC8vPT4gTWVyZ2Ugd2l0aCBjYWxjdWxhdGVkIG9wdGlvbnMgc2V0IGZvciB0aGF0IHNwZWNpZmljIHN3YWxcbiAgICAgICAgICAgIC4uLnVzZXJPcHRpb25zLFxuXG4gICAgICAgICAgICAvLz0+IEhhbmRsZSBtb2RhbCBsaWZlY3ljbGUgZXZlbnRzXG4gICAgICAgICAgICBvbkJlZm9yZU9wZW46IGNvbXBvc2VIb29rKHVzZXJPcHRpb25zLm9uQmVmb3JlT3BlbiwgKG1vZGFsRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYmVmb3JlT3Blbi5lbWl0KHsgbW9kYWxFbGVtZW50IH0pO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvbk9wZW46IGNvbXBvc2VIb29rKHVzZXJPcHRpb25zLm9uT3BlbiwgKG1vZGFsRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNDdXJyZW50bHlTaG93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuLmVtaXQoeyBtb2RhbEVsZW1lbnQgfSk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG9uUmVuZGVyOiBjb21wb3NlSG9vayh1c2VyT3B0aW9ucy5vblJlbmRlciwgKG1vZGFsRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyLmVtaXQoeyBtb2RhbEVsZW1lbnQgfSk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG9uQ2xvc2U6IGNvbXBvc2VIb29rKHVzZXJPcHRpb25zLm9uQ2xvc2UsIChtb2RhbEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzQ3VycmVudGx5U2hvd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlLmVtaXQoeyBtb2RhbEVsZW1lbnQgfSk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG9uQWZ0ZXJDbG9zZTogY29tcG9zZUhvb2sodXNlck9wdGlvbnMub25BZnRlckNsb3NlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZnRlckNsb3NlLmVtaXQoKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgb25EZXN0cm95OiBjb21wb3NlSG9vayh1c2VyT3B0aW9ucy5vbkRlc3Ryb3ksICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3kuZW1pdCgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcblxuICAgICAgICAvLz0+IFNob3cgdGhlIFN3YWwhIEFuZCB3YWl0IGZvciBjb25maXJtYXRpb24gb3IgZGltaXNzYWwuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN3YWwuZmlyZShvcHRpb25zKTtcblxuICAgICAgICAvLz0+IEVtaXQgb24gKGNvbmZpcm0pIG9yIChjYW5jZWwpXG4gICAgICAgIGlmICgndmFsdWUnIGluIHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5jb25maXJtLmVtaXQocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsLmVtaXQocmVzdWx0LmRpc21pc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICBmdW5jdGlvbiBjb21wb3NlSG9vazxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkPihcbiAgICAgICAgICAgIHVzZXJIb29rOiBUIHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgbGliSG9vazogVCk6ICguLi5hcmdzOiBQYXJhbWV0ZXJzPFQ+KSA9PiB2b2lkIHtcblxuICAgICAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiAobGliSG9vayguLi5hcmdzKSwgdXNlckhvb2s/LiguLi5hcmdzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIG1vZGFsLCBpZiBvcGVuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVzdWx0IFRoZSB2YWx1ZSB0aGF0IHRoZSBtb2RhbCB3aWxsIHJlc29sdmUgd2l0aCwgdHJpZ2dlcmluZyBlaXRoZXIgKGNvbmZpcm0pIG9yIChjYW5jZWwpLlxuICAgICAqICAgICAgICAgICAgICAgSWYgdGhlIGFyZ3VtZW50IGlzIG5vdCBwYXNzZWQsIChkaW1pc3MpIHdpbGwgZW1pdCBgdW5kZWZpbmVkYC5cbiAgICAgKiAgICAgICAgICAgICAgIFNlZSB7QGxpbmsgU3dhbC5jbG9zZX1cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZGlzbWlzcyhyZXN1bHQ/OiBTd2VldEFsZXJ0UmVzdWx0KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmICghdGhpcy5pc0N1cnJlbnRseVNob3duKSByZXR1cm47XG5cbiAgICAgICAgY29uc3Qgc3dhbCA9IGF3YWl0IHRoaXMuc3dlZXRBbGVydDJMb2FkZXIuc3dhbDtcbiAgICAgICAgc3dhbC5jbG9zZShyZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgU3dlZXRBbGVydDIgb3B0aW9ucyB3aGlsZSB0aGUgbW9kYWwgaXMgb3BlbmVkLCBjYXVzaW5nIHRoZSBtb2RhbCB0byByZS1yZW5kZXIuXG4gICAgICogSWYgdGhlIG1vZGFsIGlzIG5vdCBvcGVuZWQsIHRoZSBjb21wb25lbnQgb3B0aW9ucyB3aWxsIHNpbXBseSBiZSB1cGRhdGVkIGFuZCB0aGF0J3MgaXQuXG4gICAgICpcbiAgICAgKiAvIVxcIFBsZWFzZSBub3RlIHRoYXQgbm90IGFsbCBTd2VldEFsZXJ0MiBvcHRpb25zIGFyZSB1cGRhdGFibGUgd2hpbGUgdGhlIG1vZGFsIGlzIG9wZW5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIHVwZGF0ZShvcHRpb25zPzogUGljazxTd2VldEFsZXJ0T3B0aW9ucywgU3dlZXRBbGVydFVwZGF0YWJsZVBhcmFtZXRlcnM+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnN3YWxPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5pc0N1cnJlbnRseVNob3duKSByZXR1cm47XG5cbiAgICAgICAgY29uc3Qgc3dhbCA9IGF3YWl0IHRoaXMuc3dlZXRBbGVydDJMb2FkZXIuc3dhbDtcblxuICAgICAgICBjb25zdCBhbGxPcHRpb25zID0gdGhpcy5zd2FsT3B0aW9ucztcblxuICAgICAgICBjb25zdCB1cGRhdGFibGVPcHRpb25zID0gT2JqZWN0LmtleXMoYWxsT3B0aW9ucylcbiAgICAgICAgICAgIC5maWx0ZXIoc3dhbC5pc1VwZGF0YWJsZVBhcmFtZXRlcilcbiAgICAgICAgICAgIC5yZWR1Y2U8UGljazxTd2VldEFsZXJ0T3B0aW9ucywgU3dlZXRBbGVydFVwZGF0YWJsZVBhcmFtZXRlcnM+PihcbiAgICAgICAgICAgICAgICAob2JqLCBrZXkpID0+ICh7IC4uLm9iaiwgW2tleV06IGFsbE9wdGlvbnNba2V5XSB9KSxcbiAgICAgICAgICAgICAgICB7fSk7XG5cbiAgICAgICAgc3dhbC51cGRhdGUodXBkYXRhYmxlT3B0aW9ucyk7XG4gICAgfVxufVxuIl19