(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('rxjs/operators'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('@sweetalert2/ngx-sweetalert2', ['exports', '@angular/core', 'rxjs', 'rxjs/operators', '@angular/common'], factory) :
    (global = global || self, factory((global.Sweetalert2 = global.Sweetalert2 || {}, global.Sweetalert2['ngx-sweetalert2'] = {}), global.ng.core, global.rxjs, global.rxjs.operators, global.ng.common));
}(this, (function (exports, core, rxjs, operators, common) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __createBinding(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }

    function __exportStar(m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var swalProviderToken = new core.InjectionToken('@sweetalert2/ngx-sweetalert2#swalProvider');
    var fireOnInitToken = new core.InjectionToken('@sweetalert2/ngx-sweetalert2#fireOnInit');
    var dismissOnDestroyToken = new core.InjectionToken('@sweetalert2/ngx-sweetalert2#dismissOnDestroy');

    var SweetAlert2LoaderService = /** @class */ (function () {
        // Using any because Angular metadata generator does not understand a pure TS type here
        function SweetAlert2LoaderService(swalProvider) {
            this.swalProvider = swalProvider;
        }
        Object.defineProperty(SweetAlert2LoaderService.prototype, "swal", {
            get: function () {
                if (!this.swalPromiseCache) {
                    this.preloadSweetAlertLibrary();
                }
                return this.swalPromiseCache;
            },
            enumerable: true,
            configurable: true
        });
        SweetAlert2LoaderService.prototype.preloadSweetAlertLibrary = function () {
            if (this.swalPromiseCache)
                return;
            var libPromise = isLoader(this.swalProvider)
                ? this.swalProvider()
                : Promise.resolve(this.swalProvider);
            this.swalPromiseCache = libPromise.then(function (value) { return isDefaultExport(value) ? value : value.default; });
            function isLoader(value) {
                return typeof value === 'function' && value.version === undefined;
            }
            function isDefaultExport(value) {
                return typeof value === 'function';
            }
        };
        SweetAlert2LoaderService.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [swalProviderToken,] }] }
        ]; };
        SweetAlert2LoaderService = __decorate([
            core.Injectable(),
            __param(0, core.Inject(swalProviderToken))
        ], SweetAlert2LoaderService);
        return SweetAlert2LoaderService;
    }());

    /**
     * <swal> component. See the README.md for usage.
     *
     * It contains a bunch of @Inputs that have a perfect 1:1 mapping with SweetAlert2 options.
     * Their types are directly coming from SweetAlert2 types defintitions, meaning that ngx-sweetalert2 is tightly coupled
     * to SweetAlert2, but also is type-safe.
     *
     * (?) If you want to use an object that declares the SweetAlert2 options all at once rather than many @Inputs,
     *     take a look at [swalOptions], that lets you pass a full {@link SweetAlertOptions} object.
     *
     * (?) If you are reading the TypeScript source of this component, you may think that it's a lot of code.
     *     Be sure that a lot of this code is types and Angular boilerplate. Compiled and minified code is much smaller.
     *     If you are really concerned about performance and/or don't care about the API and its convenient integration
     *     with Angular (notably change detection and transclusion), you may totally use SweetAlert2 natively as well ;)
     *
     * /!\ Some SweetAlert options aren't @Inputs but @Outputs: onBeforeOpen, onOpen, onClose, onAfterClose and onDestroy
     *     (but without "on*" prefix to respect community standards).
     *     However, preConfirm and inputValidator are still @Inputs because there are not event handlers, there can't be
     *     multiple listeners and we need the values they can/must return.
     */
    var SwalComponent = /** @class */ (function () {
        function SwalComponent(sweetAlert2Loader, moduleLevelFireOnInit, moduleLevelDismissOnDestroy) {
            this.sweetAlert2Loader = sweetAlert2Loader;
            this.moduleLevelFireOnInit = moduleLevelFireOnInit;
            this.moduleLevelDismissOnDestroy = moduleLevelDismissOnDestroy;
            /**
             * Emits an event when the modal DOM element has been created.
             * Useful to perform DOM mutations before the modal is shown.
             */
            this.beforeOpen = new core.EventEmitter();
            /**
             * Emits an event when the modal is shown.
             */
            this.open = new core.EventEmitter();
            /**
             * Emits an event when the modal DOM is rendered.
             */
            this.render = new core.EventEmitter();
            /**
             * Emits an event when the modal will be closed.
             * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.
             */
            this.close = new core.EventEmitter();
            /**
             * Emits an event after the modal had been closed.
             * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.
             */
            this.afterClose = new core.EventEmitter();
            /**
             * Emits an event after the modal had been closed.
             * The difference between {@link destroy} and {@link afterClose} is that the latter is called for user interactions
             * only (clicks), whereas {@link destroy} is always called, both for user interactions and popup being closed by
             * another popup.
             */
            this.destroy = new core.EventEmitter();
            /**
             * Emits when the user clicks "Confirm".
             * Bears a value when using "input", resolved "preConfirm", etc.
             *
             * Example:
             *     <swal (confirm)="handleConfirm($event)"></swal>
             *
             *     public handleConfirm(email: string): void {
             *         // ... save user email
             *     }
             */
            this.confirm = new core.EventEmitter();
            /**
             * Emits when the user clicks "Cancel", or dismisses the modal by any other allowed way.
             * By default, it will emit a string representing the reason for which the SweetAlert has been closed.
             * The reason is `undefined` when {@link dismiss} is called.
             *
             * Example:
             *     <swal (cancel)="handleCancel($event)"></swal>
             *
             *     public handleCancel(reason: DismissReason | undefined): void {
             *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.
             *         // ... do something
             *     }
             */
            this.cancel = new core.EventEmitter();
            /**
             * This Set retains the properties that have been changed from @Inputs, so we can know precisely
             * what options we have to send to {@link Swal.fire}.
             */
            this.touchedProps = new Set();
            /**
             * A function of signature `(propName: string): void` that adds a given property name to the list of
             * touched properties, ie. {@link touchedProps}.
             */
            this.markTouched = this.touchedProps.add.bind(this.touchedProps);
            /**
             * Is the SweetAlert2 modal represented by this component currently opened?
             */
            this.isCurrentlyShown = false;
        }
        Object.defineProperty(SwalComponent.prototype, "swalOptions", {
            /**
             * Computes the options object that will get passed to SweetAlert2.
             * Only the properties that have been set at least once on this component will be returned.
             * Mostly for internal usage.
             */
            get: function () {
                var _this = this;
                //=> We will compute the options object based on the option keys that are known to have changed.
                //   That avoids passing a gigantic object to SweetAlert2, making debugging easier and potentially
                //   avoiding side effects.
                return __spread(this.touchedProps).reduce(function (obj, key) {
                    var _a;
                    return (__assign(__assign({}, obj), (_a = {}, _a[key] = _this[key], _a)));
                }, {});
            },
            /**
             * An object of SweetAlert2 native options, useful if:
             *  - you don't want to use the @Inputs for practical/philosophical reasons ;
             *  - there are missing @Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.
             *
             * /!\ Please note that setting this property does NOT erase what has been set before unless you specify the
             *     previous properties you want to erase again.
             *     Ie. setting { title: 'Title' } and then { text: 'Text' } will give { title: 'Title', text: 'Text' }.
             *
             * /!\ Be aware that the options defined in this object will override the @Inputs of the same name.
             */
            set: function (options) {
                //=> Update properties
                Object.assign(this, options);
                //=> Mark changed properties as touched
                var touchedKeys = Object.keys(options);
                touchedKeys.forEach(this.markTouched);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SwalComponent.prototype, "swalVisible", {
            get: function () {
                return this.isCurrentlyShown;
            },
            set: function (visible) {
                visible ? this.fire() : this.dismiss();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Angular lifecycle hook.
         * Asks the SweetAlert2 loader service to preload the SweetAlert2 library, so it begins to be loaded only if there
         * is a <swal> component somewhere, and is probably fully loaded when the modal has to be displayed,
         * causing no delay.
         */
        SwalComponent.prototype.ngOnInit = function () {
            //=> Preload SweetAlert2 library in case this component is activated.
            this.sweetAlert2Loader.preloadSweetAlertLibrary();
        };
        /**
         * Angular lifecycle hook.
         * Fires the modal, if the component or module is configured to do so.
         */
        SwalComponent.prototype.ngAfterViewInit = function () {
            var fireOnInit = this.swalFireOnInit === undefined
                ? this.moduleLevelFireOnInit
                : this.swalFireOnInit;
            fireOnInit && this.fire();
        };
        /**
         * Angular lifecycle hook.
         * Updates the SweetAlert options, and if the modal is opened, asks SweetAlert to render it again.
         */
        SwalComponent.prototype.ngOnChanges = function (changes) {
            //=> For each changed @Input that matches a SweetAlert2 option, mark as touched so we can
            //   send it with the next fire() or update() calls.
            Object.keys(changes)
                //=> If the filtering logic becomes more complex here, we can use Swal.isValidParameter
                .filter(function (key) { return !key.startsWith('swal'); })
                .forEach(this.markTouched);
            //=> Eventually trigger re-render if the modal is open.
            void this.update();
        };
        /**
         * Angular lifecycle hook.
         * Closes the SweetAlert when the component is destroyed.
         */
        SwalComponent.prototype.ngOnDestroy = function () {
            //=> Release the modal if the component is destroyed and if that behaviour is not disabled.
            var dismissOnDestroy = this.swalDismissOnDestroy === undefined
                ? this.moduleLevelDismissOnDestroy
                : this.swalDismissOnDestroy;
            dismissOnDestroy && this.dismiss();
        };
        /**
         * Shows the SweetAlert.
         *
         * Returns the SweetAlert2 promise for convenience and use in code behind templates.
         * Otherwise, (confirm)="myHandler($event)" and (cancel)="myHandler($event)" can be used in templates.
         */
        SwalComponent.prototype.fire = function () {
            return __awaiter(this, void 0, void 0, function () {
                function composeHook(userHook, libHook) {
                    return function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        return (libHook.apply(void 0, __spread(args)), userHook === null || userHook === void 0 ? void 0 : userHook.apply(void 0, __spread(args)));
                    };
                }
                var swal, userOptions, options, result;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.sweetAlert2Loader.swal];
                        case 1:
                            swal = _a.sent();
                            userOptions = this.swalOptions;
                            options = __assign(__assign({}, userOptions), { 
                                //=> Handle modal lifecycle events
                                onBeforeOpen: composeHook(userOptions.onBeforeOpen, function (modalElement) {
                                    _this.beforeOpen.emit({ modalElement: modalElement });
                                }), onOpen: composeHook(userOptions.onOpen, function (modalElement) {
                                    _this.isCurrentlyShown = true;
                                    _this.open.emit({ modalElement: modalElement });
                                }), onRender: composeHook(userOptions.onRender, function (modalElement) {
                                    _this.render.emit({ modalElement: modalElement });
                                }), onClose: composeHook(userOptions.onClose, function (modalElement) {
                                    _this.isCurrentlyShown = false;
                                    _this.close.emit({ modalElement: modalElement });
                                }), onAfterClose: composeHook(userOptions.onAfterClose, function () {
                                    _this.afterClose.emit();
                                }), onDestroy: composeHook(userOptions.onDestroy, function () {
                                    _this.destroy.emit();
                                }) });
                            return [4 /*yield*/, swal.fire(options)];
                        case 2:
                            result = _a.sent();
                            //=> Emit on (confirm) or (cancel)
                            if ('value' in result) {
                                this.confirm.emit(result.value);
                            }
                            else {
                                this.cancel.emit(result.dismiss);
                            }
                            return [2 /*return*/, result];
                    }
                });
            });
        };
        /**
         * Closes the modal, if opened.
         *
         * @param result The value that the modal will resolve with, triggering either (confirm) or (cancel).
         *               If the argument is not passed, (dimiss) will emit `undefined`.
         *               See {@link Swal.close}
         */
        SwalComponent.prototype.dismiss = function (result) {
            return __awaiter(this, void 0, void 0, function () {
                var swal;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.isCurrentlyShown)
                                return [2 /*return*/];
                            return [4 /*yield*/, this.sweetAlert2Loader.swal];
                        case 1:
                            swal = _a.sent();
                            swal.close(result);
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Updates SweetAlert2 options while the modal is opened, causing the modal to re-render.
         * If the modal is not opened, the component options will simply be updated and that's it.
         *
         * /!\ Please note that not all SweetAlert2 options are updatable while the modal is opened.
         *
         * @param options
         */
        SwalComponent.prototype.update = function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var swal, allOptions, updatableOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (options) {
                                this.swalOptions = options;
                            }
                            if (!this.isCurrentlyShown)
                                return [2 /*return*/];
                            return [4 /*yield*/, this.sweetAlert2Loader.swal];
                        case 1:
                            swal = _a.sent();
                            allOptions = this.swalOptions;
                            updatableOptions = Object.keys(allOptions)
                                .filter(swal.isUpdatableParameter)
                                .reduce(function (obj, key) {
                                var _a;
                                return (__assign(__assign({}, obj), (_a = {}, _a[key] = allOptions[key], _a)));
                            }, {});
                            swal.update(updatableOptions);
                            return [2 /*return*/];
                    }
                });
            });
        };
        SwalComponent.ctorParameters = function () { return [
            { type: SweetAlert2LoaderService },
            { type: Boolean, decorators: [{ type: core.Inject, args: [fireOnInitToken,] }] },
            { type: Boolean, decorators: [{ type: core.Inject, args: [dismissOnDestroyToken,] }] }
        ]; };
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "title", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "titleText", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "text", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "html", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "footer", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "icon", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "iconHtml", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "backdrop", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "toast", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "target", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "input", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "width", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "padding", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "background", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "position", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "grow", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "showClass", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "hideClass", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "customClass", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "timer", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "timerProgressBar", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "animation", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "heightAuto", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "allowOutsideClick", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "allowEscapeKey", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "allowEnterKey", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "stopKeydownPropagation", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "keydownListenerCapture", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "showConfirmButton", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "showCancelButton", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "confirmButtonText", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "cancelButtonText", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "confirmButtonColor", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "cancelButtonColor", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "confirmButtonAriaLabel", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "cancelButtonAriaLabel", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "buttonsStyling", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "reverseButtons", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "focusConfirm", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "focusCancel", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "showCloseButton", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "closeButtonHtml", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "closeButtonAriaLabel", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "showLoaderOnConfirm", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "preConfirm", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "imageUrl", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "imageWidth", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "imageHeight", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "imageAlt", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "inputPlaceholder", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "inputValue", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "inputOptions", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "inputAutoTrim", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "inputAttributes", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "inputValidator", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "validationMessage", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "progressSteps", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "currentProgressStep", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "progressStepsDistance", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "scrollbarPadding", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "swalOptions", null);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "swalFireOnInit", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "swalDismissOnDestroy", void 0);
        __decorate([
            core.Input()
        ], SwalComponent.prototype, "swalVisible", null);
        __decorate([
            core.Output()
        ], SwalComponent.prototype, "beforeOpen", void 0);
        __decorate([
            core.Output()
        ], SwalComponent.prototype, "open", void 0);
        __decorate([
            core.Output()
        ], SwalComponent.prototype, "render", void 0);
        __decorate([
            core.Output()
        ], SwalComponent.prototype, "close", void 0);
        __decorate([
            core.Output()
        ], SwalComponent.prototype, "afterClose", void 0);
        __decorate([
            core.Output()
        ], SwalComponent.prototype, "destroy", void 0);
        __decorate([
            core.Output()
        ], SwalComponent.prototype, "confirm", void 0);
        __decorate([
            core.Output()
        ], SwalComponent.prototype, "cancel", void 0);
        SwalComponent = __decorate([
            core.Component({
                // tslint:disable-next-line:component-selector
                selector: 'swal',
                template: '',
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __param(1, core.Inject(fireOnInitToken)),
            __param(2, core.Inject(dismissOnDestroyToken))
        ], SwalComponent);
        return SwalComponent;
    }());

    /**
     * [swal] directive. It takes a value that defines the SweetAlert and can be of three types:
     *
     * 1) A simple array of two or three strings defining [title, text, icon] - the icon being optional, ex:
     *
     *    <button [swal]="['Title', 'Text']">Click me</button>
     *
     * 2) A native SweetAlert2 options object, ex:
     *
     *    <button [swal]="{ title: 'Title', text: 'Text' }">Click me</button>
     *
     * 3) A reference to an existing SwalComponent instance for more advanced uses, ex:
     *
     *    <button [swal]="mySwal">Click me</button>
     *    <swal #mySwal title="Title" text="Text"></swal>
     */
    var SwalDirective = /** @class */ (function () {
        function SwalDirective(viewContainerRef, resolver) {
            this.viewContainerRef = viewContainerRef;
            this.resolver = resolver;
            /**
             * Emits when the user clicks "Confirm".
             * Bears a value when using "input", resolved "preConfirm", etc.
             *
             * Example:
             *     <swal (confirm)="handleConfirm($event)"></swal>
             *
             *     public handleConfirm(email: string): void {
             *         // ... save user email
             *     }
             */
            this.confirm = new core.EventEmitter();
            /**
             * Emits when the user clicks "Cancel", or dismisses the modal by any other allowed way.
             * By default, it will emit a string representing the reason for which the SweetAlert has been closed.
             * The reason is `undefined` when {@link dismiss} is called.
             *
             * Example:
             *     <swal (cancel)="handleCancel($event)"></swal>
             *
             *     public handleCancel(reason: DismissReason | undefined): void {
             *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.
             *         // ... do something
             *     }
             */
            this.cancel = new core.EventEmitter();
        }
        Object.defineProperty(SwalDirective.prototype, "swal", {
            /**
             * SweetAlert2 options or a SwalComponent instance.
             * See the class doc block for more informations.
             */
            set: function (options) {
                var _a;
                if (options instanceof SwalComponent) {
                    this.swalInstance = options;
                }
                else if (isArrayOptions(options)) {
                    this.swalOptions = {};
                    _a = __read(options, 3), this.swalOptions.title = _a[0], this.swalOptions.text = _a[1], this.swalOptions.icon = _a[2];
                }
                else {
                    this.swalOptions = options;
                }
                function isArrayOptions(value) {
                    return Array.isArray(options);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * OnInit lifecycle handler.
         * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm) and
         * (cancel) outputs to reemit on the directive.
         */
        SwalDirective.prototype.ngOnInit = function () {
            if (!this.swalInstance) {
                var factory = this.resolver.resolveComponentFactory(SwalComponent);
                this.swalRef = this.viewContainerRef.createComponent(factory);
                this.swalInstance = this.swalRef.instance;
            }
        };
        /**
         * OnDestroy lifecycle handler.
         * Destroys the dynamically-created SwalComponent.
         */
        SwalDirective.prototype.ngOnDestroy = function () {
            if (this.swalRef) {
                this.swalRef.destroy();
            }
        };
        /**
         * Click handler.
         * The directive listens for onclick events on its host element.
         * When this happens, it shows the <swal> attached to this directive.
         */
        SwalDirective.prototype.onClick = function (event) {
            var _this = this;
            event.preventDefault();
            event.stopImmediatePropagation();
            event.stopPropagation();
            if (!this.swalInstance)
                return;
            if (this.swalOptions) {
                this.swalInstance.swalOptions = this.swalOptions;
            }
            var swalClosed = new rxjs.Subject();
            this.swalInstance.confirm.asObservable().pipe(operators.takeUntil(swalClosed)).subscribe(function (v) { return _this.confirm.emit(v); });
            this.swalInstance.cancel.asObservable().pipe(operators.takeUntil(swalClosed)).subscribe(function (v) { return _this.cancel.emit(v); });
            this.swalInstance.fire().then(function () { return swalClosed.next(); });
        };
        SwalDirective.ctorParameters = function () { return [
            { type: core.ViewContainerRef },
            { type: core.ComponentFactoryResolver }
        ]; };
        __decorate([
            core.Input()
        ], SwalDirective.prototype, "swal", null);
        __decorate([
            core.Output()
        ], SwalDirective.prototype, "confirm", void 0);
        __decorate([
            core.Output()
        ], SwalDirective.prototype, "cancel", void 0);
        __decorate([
            core.HostListener('click', ['$event'])
        ], SwalDirective.prototype, "onClick", null);
        SwalDirective = __decorate([
            core.Directive({
                selector: '[swal]'
            })
        ], SwalDirective);
        return SwalDirective;
    }());

    /**
     * Represents an object of targets for <swal> portals (use with *swalPortal directive).
     * We must use thunks to access the Swal.* functions listed below, because they get created after the first modal is
     * shown, so this object lets us reference those functions safely and in a statically-typed manner.
     */
    var SwalPortalTargets = /** @class */ (function () {
        function SwalPortalTargets() {
            /**
             * Targets the modal close button block contents.
             */
            this.closeButton = {
                element: function (swal) { return swal.getCloseButton(); },
                options: { showCloseButton: true }
            };
            /**
             * Targets the modal title block contents.
             */
            this.title = {
                element: function (swal) { return swal.getTitle(); },
                // Empty text that will never be shown but necessary so SweetAlert2 makes the div visible.
                options: { title: ' ' }
            };
            /**
             * Targets the modal text block contents (that is another block inside the first content block, so you can still
             * use other modal features like Swal inputs, that are situated inside that parent content block).
             */
            this.content = {
                element: function (swal) { return swal.getHtmlContainer(); },
                // Empty text that will never be shown but necessary so SweetAlert2 makes the div visible.
                options: { text: ' ' }
            };
            /**
             * Targets the actions block contents, where are the confirm and cancel buttons in a normal time.
             * /!\ WARNING: using this target destroys some of the native SweetAlert2 modal's DOM, therefore, if you use this
             *     target, do not update the modal via <swal> @Inputs while the modal is open, or you'll get an error.
             *     We could workaround that inconvenient inside this integration, but that'd be detrimental to memory and
             *     performance of everyone, for a relatively rare use case.
             */
            this.actions = {
                element: function (swal) { return swal.getActions(); },
                // The button will never exist, but SweetAlert2 shows the actions block only if there is at least one button.
                options: { showConfirmButton: true }
            };
            /**
             * Targets the confirm button contents, replacing the text inside it (not the button itself)
             */
            this.confirmButton = {
                element: function (swal) { return swal.getConfirmButton(); },
                options: { showConfirmButton: true }
            };
            /**
             * Targets the cancel button contents, replacing the text inside it (not the button itself)
             */
            this.cancelButton = {
                element: function (swal) { return swal.getCancelButton(); },
                options: { showCancelButton: true }
            };
            /**
             * Targets the modal footer contents.
             */
            this.footer = {
                element: function (swal) { return swal.getFooter(); },
                // Empty text that will never be shown but necessary so SweetAlert2 makes the div visible.
                options: { footer: ' ' }
            };
        }
        SwalPortalTargets.ɵprov = core.ɵɵdefineInjectable({ factory: function SwalPortalTargets_Factory() { return new SwalPortalTargets(); }, token: SwalPortalTargets, providedIn: "root" });
        SwalPortalTargets = __decorate([
            core.Injectable({ providedIn: 'root' })
        ], SwalPortalTargets);
        return SwalPortalTargets;
    }());

    /**
     * @internal
     * Holds a consumer's Angular template and displays it on a Sweet Alert.
     * See SwalPortalDirective for info about the covered feature.
     */
    var SwalPortalComponent = /** @class */ (function () {
        function SwalPortalComponent() {
            this.template = null;
        }
        __decorate([
            core.Input()
        ], SwalPortalComponent.prototype, "template", void 0);
        SwalPortalComponent = __decorate([
            core.Component({
                selector: 'swal-portal',
                template: '<ng-container *ngTemplateOutlet="template"></ng-container>',
                changeDetection: core.ChangeDetectionStrategy.OnPush
            })
        ], SwalPortalComponent);
        return SwalPortalComponent;
    }());

    /**
     * A structural directive that lets you use Angular templates inside of SweetAlerts.
     * There are different targetable zones provided by {@link SwalPortalTargets}: title, content, confirmButton, etc, but
     * you can also make your own target by implementing {@link SwalPortalTarget} and giving it to this directive.
     * The default target is the alert text content zone.
     *
     * Usage in your component's TypeScript (if you use another target than {@link SwalPortalTargets.content}):
     *
     *     @Component({ ... })
     *     export class MyComponent {
     *         public constructor(public readonly swalTargets: SwalPortalTargets) {
     *         }
     *     }
     *
     * Usage in the template:
     *
     *     <swal title="Fill the form" (confirm)="confirmHandler()">
     *         <!-- This form will be displayed as the alert main content
     *              Targets the alert's main content zone by default -->
     *         <form *swalPortal [formControl]="myForm">
     *             ...
     *         </form>
     *
     *         <!-- This targets the confirm button's inner content
     *              Notice the usage of ng-container to avoid creating an useless DOM element inside the button -->
     *         <ng-container *swalPortal="swalTargets.confirmButton">
     *              Send ({{ secondsLeft }} seconds left)
     *         </ng-container>
     *     <swal>
     */
    var SwalPortalDirective = /** @class */ (function () {
        function SwalPortalDirective(resolver, injector, app, templateRef, sweetAlert2Loader, swalTargets, swalComponent) {
            this.resolver = resolver;
            this.injector = injector;
            this.app = app;
            this.templateRef = templateRef;
            this.sweetAlert2Loader = sweetAlert2Loader;
            this.swalTargets = swalTargets;
            this.swalComponent = swalComponent;
            this.destroyed = new rxjs.Subject();
        }
        /**
         * Subscribes to the the SweetAlert appearance/disappearance events to create/destroy the SwalPortalComponent
         * that will receive the consumer's template.
         */
        SwalPortalDirective.prototype.ngOnInit = function () {
            // Can't be set in a default property value, if the customer lets *swalPortal empty, the value we get is undef.
            this.target = this.target || this.swalTargets.content;
            //=> Apply the options provided by the target definition
            void this.swalComponent.update(this.target.options);
            //=> Subscribe to a few hooks frm the parent SwalComponent.
            this.swalComponent.render.pipe(operators.takeUntil(this.destroyed)).subscribe(this.renderHook.bind(this));
            this.swalComponent.beforeOpen.pipe(operators.takeUntil(this.destroyed)).subscribe(this.beforeOpenHook.bind(this));
            this.swalComponent.destroy.pipe(operators.takeUntil(this.destroyed)).subscribe(this.destroyHook.bind(this));
        };
        /**
         * Signal any {@link destroyed} consumer that this is over, so they can unsubscribe from the
         * parent SwalComponent events.
         */
        SwalPortalDirective.prototype.ngOnDestroy = function () {
            this.destroyed.next();
        };
        /**
         * This render hook runs 1..n times (per modal instance), just before the modal is shown (and also before the
         * {@link beforeOpenHook}), or after Swal.update() is called.
         * This is a good place to render, or re-render, our portal contents.
         */
        SwalPortalDirective.prototype.renderHook = function () {
            return __awaiter(this, void 0, void 0, function () {
                var swal, targetEl;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            //=> Ensure the portal component is created
                            if (!this.portalComponentRef) {
                                this.portalComponentRef = this.createPortalComponent();
                            }
                            return [4 /*yield*/, this.sweetAlert2Loader.swal];
                        case 1:
                            swal = _a.sent();
                            targetEl = this.target.element(swal);
                            if (!targetEl)
                                return [2 /*return*/];
                            //=> Replace target's contents with our component
                            // https://jsperf.com/innerhtml-vs-removechild/15
                            while (targetEl.firstChild) {
                                targetEl.removeChild(targetEl.firstChild);
                            }
                            targetEl.appendChild(this.portalComponentRef.location.nativeElement);
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * This beforeOpen hook runs once (per modal instance), just before the modal is shown on the screen.
         * This is a good place to declare our detached view to the Angular app.
         */
        SwalPortalDirective.prototype.beforeOpenHook = function () {
            if (!this.portalComponentRef)
                return;
            //=> Make the Angular app aware of that detached view so rendering and change detection can happen
            this.app.attachView(this.portalComponentRef.hostView);
        };
        /**
         * This afterClose hook runs once (per modal instance), just after the modal closing animation terminated.
         * This is a good place to detach and destroy our content, that is not visible anymore.
         */
        SwalPortalDirective.prototype.destroyHook = function () {
            if (!this.portalComponentRef)
                return;
            //=> Detach the portal component from the app and destroy it
            this.app.detachView(this.portalComponentRef.hostView);
            this.portalComponentRef.destroy();
            this.portalComponentRef = void 0;
        };
        /**
         * Creates the {@link SwalPortalComponent} and gives it the customer's template ref.
         */
        SwalPortalDirective.prototype.createPortalComponent = function () {
            //=> Create the SwalPortalComponent that will hold our content
            var factory = this.resolver.resolveComponentFactory(SwalPortalComponent);
            // Yes, we do not use the third argument that would directly use the target as the component's view
            // (unfortunately, because that would give a cleaner DOM and would avoid dirty and direct DOM manipulations)
            // That's because we want to keep our component safe from SweetAlert2's operations on the DOM, and to be
            // able to restore it at any moment, ie. after the modal has been re-rendered.
            var componentRef = factory.create(this.injector, []);
            //=> Apply the consumer's template on the component
            componentRef.instance.template = this.templateRef;
            return componentRef;
        };
        SwalPortalDirective.ctorParameters = function () { return [
            { type: core.ComponentFactoryResolver },
            { type: core.Injector },
            { type: core.ApplicationRef },
            { type: core.TemplateRef },
            { type: SweetAlert2LoaderService },
            { type: SwalPortalTargets },
            { type: SwalComponent, decorators: [{ type: core.Host }] }
        ]; };
        __decorate([
            core.Input('swalPortal')
        ], SwalPortalDirective.prototype, "target", void 0);
        SwalPortalDirective = __decorate([
            core.Directive({
                selector: '[swalPortal]'
            }),
            __param(6, core.Host())
        ], SwalPortalDirective);
        return SwalPortalDirective;
    }());

    function provideDefaultSwal() {
        return import('sweetalert2');
    }
    var SweetAlert2Module = /** @class */ (function () {
        function SweetAlert2Module() {
        }
        SweetAlert2Module_1 = SweetAlert2Module;
        SweetAlert2Module.forRoot = function (options) {
            if (options === void 0) { options = {}; }
            return {
                ngModule: SweetAlert2Module_1,
                providers: [
                    SweetAlert2LoaderService,
                    { provide: swalProviderToken, useValue: options.provideSwal || provideDefaultSwal },
                    { provide: fireOnInitToken, useValue: options.fireOnInit || false },
                    { provide: dismissOnDestroyToken, useValue: options.dismissOnDestroy || true }
                ]
            };
        };
        SweetAlert2Module.forChild = function (options) {
            if (options === void 0) { options = {}; }
            return {
                ngModule: SweetAlert2Module_1,
                providers: __spread(options.provideSwal ? [
                    SweetAlert2LoaderService,
                    { provide: swalProviderToken, useValue: options.provideSwal }
                ] : [], options.fireOnInit !== undefined ? [
                    { provide: fireOnInitToken, useValue: options.fireOnInit }
                ] : [], options.dismissOnDestroy !== undefined ? [
                    { provide: dismissOnDestroyToken, useValue: options.dismissOnDestroy }
                ] : [])
            };
        };
        var SweetAlert2Module_1;
        SweetAlert2Module = SweetAlert2Module_1 = __decorate([
            core.NgModule({
                declarations: [
                    SwalDirective, SwalComponent, SwalPortalDirective, SwalPortalComponent
                ],
                imports: [
                    common.CommonModule
                ],
                exports: [
                    SwalComponent, SwalPortalDirective, SwalDirective
                ],
                entryComponents: [
                    SwalComponent, SwalPortalComponent
                ]
            })
        ], SweetAlert2Module);
        return SweetAlert2Module;
    }());

    exports.SwalComponent = SwalComponent;
    exports.SwalDirective = SwalDirective;
    exports.SwalPortalDirective = SwalPortalDirective;
    exports.SwalPortalTargets = SwalPortalTargets;
    exports.SweetAlert2LoaderService = SweetAlert2LoaderService;
    exports.SweetAlert2Module = SweetAlert2Module;
    exports.ɵa = provideDefaultSwal;
    exports.ɵb = swalProviderToken;
    exports.ɵc = fireOnInitToken;
    exports.ɵd = dismissOnDestroyToken;
    exports.ɵe = SwalPortalComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=sweetalert2-ngx-sweetalert2.umd.js.map
